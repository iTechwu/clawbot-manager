# ClawBotManager 功能增强实施方案

> 版本：v1.2 | 日期：2026-02-05 | 最后更新：2026-02-05

---

## 实施进度

### Phase 1: 基础监控 ✅ 已完成

| 任务 | 状态 | 文件 |
|------|------|------|
| Token 提取服务 | ✅ 完成 | `apps/api/src/modules/proxy/services/token-extractor.service.ts` |
| Docker 事件监听器 | ✅ 完成 | `apps/api/src/modules/bot-api/services/docker-event.service.ts` |
| SSE 实时推送 | ✅ 完成 | `apps/api/src/modules/bot-api/services/bot-sse.service.ts` |
| 数据库迁移 | ✅ 完成 | `prisma/migrations/20260205043250_add_usage_analytics_fields/` |
| Proxy 集成 Token 提取 | ✅ 完成 | `apps/api/src/modules/proxy/services/proxy.service.ts` |
| Upstream 服务修改 | ✅ 完成 | `apps/api/src/modules/proxy/services/upstream.service.ts` |

### Phase 2: 用量分析 ✅ 已完成

| 任务 | 状态 | 文件 |
|------|------|------|
| 用量统计 Schema | ✅ 完成 | `packages/contracts/src/schemas/bot-usage.schema.ts` |
| 用量统计契约 | ✅ 完成 | `packages/contracts/src/api/bot-usage.contract.ts` |
| 用量分析服务 | ✅ 完成 | `apps/api/src/modules/bot-api/services/bot-usage-analytics.service.ts` |
| 用量 API 端点 | ✅ 完成 | `apps/api/src/modules/bot-api/bot-api.controller.ts` |
| 前端用量页面 | ✅ 完成 | `apps/web/app/[locale]/(main)/bots/[hostname]/usage/page.tsx` |
| 前端用量 Hooks | ✅ 完成 | `apps/web/hooks/useBotUsage.ts` |

### Phase 3: 健康监控 ✅ 已完成

| 任务 | 状态 | 文件 |
|------|------|------|
| 健康检查服务 | ✅ 完成 | `apps/api/src/modules/bot-api/services/health-check.service.ts` |
| 状态超时处理 | ✅ 完成 | 集成在 health-check.service.ts |
| SSE 状态推送端点 | ✅ 完成 | `apps/api/src/modules/bot-api/bot-api.controller.ts` |
| 前端 SSE Hook | ✅ 完成 | `apps/web/hooks/useBotStatusSSE.ts` |

### Phase 4: 插件系统 ✅ 已完成

| 任务 | 状态 | 文件 |
|------|------|------|
| 插件数据模型 | ✅ 完成 | `apps/api/prisma/schema.prisma` |
| 插件 Schema | ✅ 完成 | `packages/contracts/src/schemas/plugin.schema.ts` |
| 插件 API 契约 | ✅ 完成 | `packages/contracts/src/api/plugin.contract.ts` |
| 插件 API 模块 | ✅ 完成 | `apps/api/src/modules/plugin-api/` |
| 插件市场页面 | ✅ 完成 | `apps/web/app/[locale]/(main)/plugins/page.tsx` |
| Bot 插件管理 | ✅ 完成 | `apps/web/app/[locale]/(main)/bots/[hostname]/plugins/page.tsx` |

---

## 目录

1. [概述](#1-概述)
2. [Bot 监控增强](#2-bot-监控增强)
3. [API 用量分析系统](#3-api-用量分析系统)
4. [OpenClaw 插件系统集成](#4-openclaw-插件系统集成)
5. [实施优先级与路线图](#5-实施优先级与路线图)

---

## 1. 概述

### 1.1 背景

ClawBotManager 当前已实现核心功能（Bot CRUD、Provider Key 管理、AI 代理、Docker 容器编排），但在以下方面存在提升空间：

1. **Bot 监控**：Docker 容器状态与数据库状态同步存在延迟（5秒轮询）
2. **API 用量**：Token 消耗未被追踪，无法进行精细化分析
3. **插件系统**：Bot 能力固定，用户无法自定义扩展

### 1.2 目标

| 目标 | 描述 | 优先级 |
|------|------|--------|
| 实时状态同步 | Docker 容器状态变化实时反映到前端 | P0 |
| 精细化用量分析 | Token 消耗、成本、趋势数据可视化 | P0 |
| 插件生态 | 用户可安装/卸载插件扩展 Bot 能力 | P1 |

---

## 2. Bot 监控增强

### 2.1 现状分析

**当前实现：**
- 启动时对账（`ReconciliationService.onModuleInit`）
- 前端 5 秒轮询（`useBots` hook，`refetchInterval: 5000`）
- 列表查询时同步状态（`listBots` 方法内部检查）

**关键文件：**
- `apps/api/src/modules/bot-api/services/docker.service.ts`
- `apps/api/src/modules/bot-api/services/reconciliation.service.ts`
- `apps/web/hooks/useBots.ts`

**存在问题：**

| 问题 | 影响 | 严重程度 |
|------|------|----------|
| 无 Docker 事件监听 | 容器崩溃后状态延迟更新 5 秒 | 高 |
| 无实时推送 | 依赖轮询造成延迟和资源浪费 | 中 |
| 无健康检查 | 容器运行但应用异常无法检测 | 高 |
| "starting" 状态可能卡住 | 启动失败时状态不更新 | 中 |
| 无状态历史 | 无法追踪 uptime/downtime | 低 |

### 2.2 实施方案

#### 2.2.1 Docker 事件监听器

**新建文件：** `apps/api/src/modules/bot-api/services/docker-event.service.ts`

```typescript
import { Injectable, OnModuleInit, OnModuleDestroy, Inject } from '@nestjs/common';
import Docker from 'dockerode';
import { WINSTON_MODULE_PROVIDER } from 'nest-winston';
import { Logger } from 'winston';
import { BotService } from '@app/db';
import { BotSseService } from './bot-sse.service';

interface DockerEvent {
  Type: string;
  Action: string;
  Actor: {
    ID: string;
    Attributes: Record<string, string>;
  };
  time: number;
}

@Injectable()
export class DockerEventService implements OnModuleInit, OnModuleDestroy {
  private docker: Docker;
  private eventStream: NodeJS.ReadableStream | null = null;
  private reconnectTimer: NodeJS.Timeout | null = null;

  constructor(
    @Inject(WINSTON_MODULE_PROVIDER) private readonly logger: Logger,
    private readonly botService: BotService,
    private readonly sseService: BotSseService,
  ) {
    this.docker = new Docker();
  }

  async onModuleInit() {
    await this.startEventListener();
  }

  async onModuleDestroy() {
    this.stopEventListener();
  }

  private async startEventListener() {
    try {
      this.eventStream = await this.docker.getEvents({
        filters: {
          type: ['container'],
          event: ['start', 'stop', 'die', 'kill', 'oom', 'restart'],
          label: ['clawbot-manager.managed=true'],
        },
      });

      this.eventStream.on('data', (chunk) => {
        try {
          const event: DockerEvent = JSON.parse(chunk.toString());
          this.handleContainerEvent(event);
        } catch (error) {
          this.logger.error('Failed to parse Docker event', { error });
        }
      });

      this.eventStream.on('error', (error) => {
        this.logger.error('Docker event stream error', { error });
        this.scheduleReconnect();
      });

      this.logger.info('Docker event listener started');
    } catch (error) {
      this.logger.error('Failed to start Docker event listener', { error });
      this.scheduleReconnect();
    }
  }

  private stopEventListener() {
    if (this.eventStream) {
      this.eventStream.destroy();
      this.eventStream = null;
    }
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }

  private scheduleReconnect() {
    if (this.reconnectTimer) return;
    this.reconnectTimer = setTimeout(() => {
      this.reconnectTimer = null;
      this.startEventListener();
    }, 5000);
  }

  private async handleContainerEvent(event: DockerEvent) {
    const isolationKey = event.Actor.Attributes['clawbot-manager.isolation-key'];
    if (!isolationKey) return;

    const newStatus = this.mapEventToStatus(event.Action);
    this.logger.info('Container event received', {
      isolationKey,
      action: event.Action,
      newStatus,
    });

    try {
      // 1. 更新数据库状态
      const bot = await this.botService.updateStatusByIsolationKey(isolationKey, newStatus);

      if (bot) {
        // 2. 推送 SSE 事件给该用户
        this.sseService.sendToUser(bot.createdById, 'bot-status', {
          hostname: bot.hostname,
          status: newStatus,
          timestamp: new Date().toISOString(),
        });
      }
    } catch (error) {
      this.logger.error('Failed to handle container event', { isolationKey, error });
    }
  }

  private mapEventToStatus(action: string): string {
    switch (action) {
      case 'start':
      case 'restart':
        return 'running';
      case 'stop':
        return 'stopped';
      case 'die':
      case 'kill':
      case 'oom':
        return 'error';
      default:
        return 'stopped';
    }
  }
}
```

#### 2.2.2 SSE 实时状态推送

**新建文件：** `apps/api/src/modules/bot-api/services/bot-sse.service.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { Subject, Observable, filter } from 'rxjs';

interface SseEvent {
  userId: string;
  type: string;
  data: any;
}

@Injectable()
export class BotSseService {
  private eventSubject = new Subject<SseEvent>();

  sendToUser(userId: string, type: string, data: any) {
    this.eventSubject.next({ userId, type, data });
  }

  broadcast(type: string, data: any) {
    this.eventSubject.next({ userId: '*', type, data });
  }

  getUserStream(userId: string): Observable<MessageEvent> {
    return new Observable((subscriber) => {
      const subscription = this.eventSubject
        .pipe(filter((event) => event.userId === userId || event.userId === '*'))
        .subscribe({
          next: (event) => {
            subscriber.next({
              data: JSON.stringify({ type: event.type, ...event.data }),
            } as MessageEvent);
          },
        });
      return () => subscription.unsubscribe();
    });
  }
}
```

**修改文件：** `apps/api/src/modules/bot-api/bot-api.controller.ts`

```typescript
@Get('status-stream')
@Sse()
statusStream(@Req() req: FastifyRequest): Observable<MessageEvent> {
  const userId = req.userId;
  return this.botSseService.getUserStream(userId);
}
```

#### 2.2.3 健康检查服务

**新建文件：** `apps/api/src/modules/bot-api/services/health-check.service.ts`

```typescript
import { Injectable, Inject } from '@nestjs/common';
import { Cron } from '@nestjs/schedule';
import { WINSTON_MODULE_PROVIDER } from 'nest-winston';
import { Logger } from 'winston';
import { BotService } from '@app/db';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom, timeout, catchError, of } from 'rxjs';

@Injectable()
export class HealthCheckService {
  constructor(
    @Inject(WINSTON_MODULE_PROVIDER) private readonly logger: Logger,
    private readonly botService: BotService,
    private readonly httpService: HttpService,
  ) {}

  @Cron('*/30 * * * * *') // 每 30 秒
  async checkAllBots() {
    const runningBots = await this.botService.findByStatus('running');

    for (const bot of runningBots) {
      const isHealthy = await this.checkBotHealth(bot.port);

      if (!isHealthy && bot.healthStatus === 'HEALTHY') {
        await this.botService.updateHealthStatus(bot.id, 'UNHEALTHY');
        this.logger.warn('Bot health check failed', { hostname: bot.hostname });
      } else if (isHealthy && bot.healthStatus !== 'HEALTHY') {
        await this.botService.updateHealthStatus(bot.id, 'HEALTHY');
      }
    }
  }

  private async checkBotHealth(port: number): Promise<boolean> {
    try {
      const response = await firstValueFrom(
        this.httpService.get(`http://localhost:${port}/health`).pipe(
          timeout(5000),
          catchError(() => of({ status: 500 })),
        ),
      );
      return response.status === 200;
    } catch {
      return false;
    }
  }

  @Cron('*/60 * * * * *') // 每分钟
  async handleStuckStates() {
    const stuckBots = await this.botService.findStuckStarting(60000);
    for (const bot of stuckBots) {
      this.logger.warn('Bot stuck in starting state', { hostname: bot.hostname });
      await this.botService.updateStatus(bot.id, 'error');
    }
  }
}
```

#### 2.2.4 数据库扩展

**修改文件：** `apps/api/prisma/schema.prisma`

```prisma
enum HealthStatus {
  HEALTHY
  UNHEALTHY
  UNKNOWN
  @@map("health_status")
}

model Bot {
  // ... 现有字段 ...
  healthStatus    HealthStatus @default(UNKNOWN) @map("health_status")
  lastHealthCheck DateTime?    @map("last_health_check") @db.Timestamptz(6)
}
```

### 2.3 关键文件清单

| 文件 | 操作 | 说明 |
|------|------|------|
| `apps/api/src/modules/bot-api/services/docker-event.service.ts` | 新建 | Docker 事件监听 |
| `apps/api/src/modules/bot-api/services/bot-sse.service.ts` | 新建 | SSE 推送服务 |
| `apps/api/src/modules/bot-api/services/health-check.service.ts` | 新建 | 健康检查服务 |
| `apps/api/src/modules/bot-api/bot-api.controller.ts` | 修改 | 添加 SSE 端点 |
| `apps/api/src/modules/bot-api/bot-api.module.ts` | 修改 | 注册新服务 |
| `apps/api/prisma/schema.prisma` | 修改 | 添加健康状态字段 |
| `apps/web/hooks/useBotStatusSSE.ts` | 新建 | 前端 SSE Hook |

---

## 3. API 用量分析系统

### 3.1 现状分析

**当前实现：**
- `BotUsageLog` 模型存在，但 `requestTokens`/`responseTokens` 字段**未填充**
- `QuotaService` 存在但因无数据始终返回 0
- 无前端用量展示

**存在问题：**

| 问题 | 影响 | 严重程度 |
|------|------|----------|
| Token 数量未提取 | 配额系统失效 | 严重 |
| 无聚合查询 API | 无法获取统计数据 | 严重 |
| 无前端可视化 | 用户无法查看用量 | 高 |
| 无成本计算 | 无法预估费用 | 中 |

### 3.2 实施方案

#### 3.2.1 Token 提取服务

**新建文件：** `apps/api/src/modules/proxy/services/token-extractor.service.ts`

```typescript
import { Injectable } from '@nestjs/common';

export interface TokenUsage {
  requestTokens: number | null;
  responseTokens: number | null;
  model?: string;
}

@Injectable()
export class TokenExtractorService {
  extractTokens(vendor: string, responseBody: any): TokenUsage {
    if (!responseBody || typeof responseBody !== 'object') {
      return { requestTokens: null, responseTokens: null };
    }

    switch (vendor) {
      case 'openai':
      case 'azure-openai':
        return this.extractOpenAITokens(responseBody);
      case 'anthropic':
        return this.extractAnthropicTokens(responseBody);
      case 'google':
        return this.extractGoogleTokens(responseBody);
      case 'deepseek':
      case 'zhipu':
      case 'moonshot':
        return this.extractOpenAITokens(responseBody); // OpenAI 兼容格式
      default:
        return this.extractOpenAITokens(responseBody);
    }
  }

  private extractOpenAITokens(body: any): TokenUsage {
    return {
      requestTokens: body?.usage?.prompt_tokens ?? null,
      responseTokens: body?.usage?.completion_tokens ?? null,
      model: body?.model,
    };
  }

  private extractAnthropicTokens(body: any): TokenUsage {
    return {
      requestTokens: body?.usage?.input_tokens ?? null,
      responseTokens: body?.usage?.output_tokens ?? null,
      model: body?.model,
    };
  }

  private extractGoogleTokens(body: any): TokenUsage {
    return {
      requestTokens: body?.usageMetadata?.promptTokenCount ?? null,
      responseTokens: body?.usageMetadata?.candidatesTokenCount ?? null,
      model: body?.modelVersion,
    };
  }
}
```

#### 3.2.2 数据库扩展

**修改文件：** `apps/api/prisma/schema.prisma`

```prisma
model BotUsageLog {
  id             String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  botId          String   @map("bot_id") @db.Uuid
  vendor         String   @db.VarChar(50)
  providerKeyId  String?  @map("provider_key_id") @db.Uuid
  statusCode     Int?     @map("status_code")
  requestTokens  Int?     @map("request_tokens")
  responseTokens Int?     @map("response_tokens")
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  // 新增字段
  model          String?  @db.VarChar(100)
  endpoint       String?  @db.VarChar(255)
  durationMs     Int?     @map("duration_ms")
  errorMessage   String?  @map("error_message") @db.Text

  bot         Bot          @relation(fields: [botId], references: [id], onDelete: Cascade)
  providerKey ProviderKey? @relation(fields: [providerKeyId], references: [id], onDelete: SetNull)

  @@index([botId])
  @@index([createdAt])
  @@index([vendor])
  @@index([botId, createdAt])
  @@index([botId, vendor, createdAt])
  @@index([model])
  @@map("b_usage_log")
}
```

#### 3.2.3 API 契约

**新建文件：** `packages/contracts/src/schemas/bot-usage.schema.ts`

```typescript
import { z } from 'zod';

export const UsageStatsQuerySchema = z.object({
  period: z.enum(['day', 'week', 'month']).default('day'),
  startDate: z.coerce.date().optional(),
  endDate: z.coerce.date().optional(),
});

export const UsageStatsResponseSchema = z.object({
  totalTokens: z.number(),
  requestTokens: z.number(),
  responseTokens: z.number(),
  requestCount: z.number(),
  errorCount: z.number(),
  errorRate: z.number(),
  avgDurationMs: z.number().nullable(),
  estimatedCost: z.number(),
});

export const UsageTrendQuerySchema = z.object({
  granularity: z.enum(['hour', 'day', 'week']).default('day'),
  startDate: z.coerce.date(),
  endDate: z.coerce.date(),
});

export const UsageTrendResponseSchema = z.object({
  dataPoints: z.array(z.object({
    timestamp: z.coerce.date(),
    requestTokens: z.number(),
    responseTokens: z.number(),
    requestCount: z.number(),
    errorCount: z.number(),
    estimatedCost: z.number(),
  })),
});

export const UsageBreakdownQuerySchema = z.object({
  groupBy: z.enum(['vendor', 'model', 'status']).default('vendor'),
  startDate: z.coerce.date().optional(),
  endDate: z.coerce.date().optional(),
});

export const UsageBreakdownResponseSchema = z.object({
  groups: z.array(z.object({
    key: z.string(),
    requestTokens: z.number(),
    responseTokens: z.number(),
    requestCount: z.number(),
    percentage: z.number(),
    estimatedCost: z.number(),
  })),
});
```

**新建文件：** `packages/contracts/src/api/bot-usage.contract.ts`

```typescript
import { initContract } from '@ts-rest/core';
import { z } from 'zod';
import { createApiResponse } from '../base';
import {
  UsageStatsQuerySchema,
  UsageStatsResponseSchema,
  UsageTrendQuerySchema,
  UsageTrendResponseSchema,
  UsageBreakdownQuerySchema,
  UsageBreakdownResponseSchema,
} from '../schemas/bot-usage.schema';

const c = initContract();

export const botUsageContract = c.router(
  {
    getStats: {
      method: 'GET',
      path: '/:hostname/usage/stats',
      pathParams: z.object({ hostname: z.string() }),
      query: UsageStatsQuerySchema,
      responses: { 200: createApiResponse(UsageStatsResponseSchema) },
      summary: '获取 Bot 用量统计',
    },
    getTrend: {
      method: 'GET',
      path: '/:hostname/usage/trend',
      pathParams: z.object({ hostname: z.string() }),
      query: UsageTrendQuerySchema,
      responses: { 200: createApiResponse(UsageTrendResponseSchema) },
      summary: '获取 Bot 用量趋势',
    },
    getBreakdown: {
      method: 'GET',
      path: '/:hostname/usage/breakdown',
      pathParams: z.object({ hostname: z.string() }),
      query: UsageBreakdownQuerySchema,
      responses: { 200: createApiResponse(UsageBreakdownResponseSchema) },
      summary: '获取 Bot 用量分组统计',
    },
  },
  { pathPrefix: '/bot' },
);
```

#### 3.2.4 前端用量页面

**新建文件：** `apps/web/app/[locale]/(main)/bots/[hostname]/usage/page.tsx`

```tsx
'use client';

import { useState } from 'react';
import { useParams } from 'next/navigation';
import { Card, CardContent, CardHeader, CardTitle } from '@repo/ui';
import { LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer } from 'recharts';

export default function BotUsagePage() {
  const { hostname } = useParams<{ hostname: string }>();
  const [period, setPeriod] = useState<'day' | 'week' | 'month'>('week');

  // TODO: 实现 useBotUsageStats 和 useBotUsageTrend hooks

  return (
    <div className="space-y-6">
      {/* 统计卡片 */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <StatCard title="总 Token" value={0} />
        <StatCard title="请求次数" value={0} />
        <StatCard title="错误率" value="0%" />
        <StatCard title="预估成本" value="$0.00" />
      </div>

      {/* 趋势图表 */}
      <Card>
        <CardHeader>
          <CardTitle>Token 使用趋势</CardTitle>
        </CardHeader>
        <CardContent>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={[]}>
              <XAxis dataKey="timestamp" />
              <YAxis />
              <Tooltip />
              <Line type="monotone" dataKey="requestTokens" stroke="#8884d8" name="输入" />
              <Line type="monotone" dataKey="responseTokens" stroke="#82ca9d" name="输出" />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>
    </div>
  );
}

function StatCard({ title, value }: { title: string; value: string | number }) {
  return (
    <Card>
      <CardContent className="pt-6">
        <div className="text-2xl font-bold">{value}</div>
        <p className="text-xs text-muted-foreground">{title}</p>
      </CardContent>
    </Card>
  );
}
```

### 3.3 关键文件清单

| 文件 | 操作 | 说明 |
|------|------|------|
| `apps/api/src/modules/proxy/services/token-extractor.service.ts` | 新建 | Token 提取 |
| `apps/api/src/modules/proxy/services/upstream.service.ts` | 修改 | 集成 Token 提取 |
| `apps/api/src/modules/bot-api/services/bot-usage-analytics.service.ts` | 新建 | 用量分析 |
| `apps/api/prisma/schema.prisma` | 修改 | 扩展 BotUsageLog |
| `packages/contracts/src/schemas/bot-usage.schema.ts` | 新建 | 用量 Schema |
| `packages/contracts/src/api/bot-usage.contract.ts` | 新建 | 用量契约 |
| `apps/web/hooks/useBotUsage.ts` | 新建 | 前端 Hook |
| `apps/web/app/[locale]/(main)/bots/[hostname]/usage/page.tsx` | 新建 | 用量页面 |

---

## 4. OpenClaw 插件系统集成

### 4.1 OpenClaw 概述

OpenClaw 是一个开源的 AI Agent 框架，支持：
- **MCP (Model Context Protocol)** 服务器集成
- **50+ 官方扩展**（浏览器自动化、文件系统、GitHub、数据库等）
- **自定义技能创建**
- **多渠道支持**（Telegram、Discord、Slack 等）

### 4.2 集成架构

```
┌─────────────────────────────────────────────────────────────────┐
│                     ClawBotManager                               │
├─────────────────────────────────────────────────────────────────┤
│  Plugin Registry                                                 │
│  - 官方插件目录                                                   │
│  - 用户自定义插件                                                 │
│  - 插件版本管理                                                   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Bot Container (OpenClaw)                     │
├─────────────────────────────────────────────────────────────────┤
│  /workspace/                                                     │
│  ├── config.json          # Bot 配置                             │
│  ├── soul.md              # 人格定义                             │
│  ├── features.json        # 功能开关                             │
│  ├── mcp-servers.json     # MCP 服务器配置 (NEW)                 │
│  └── plugins/             # 插件目录 (NEW)                       │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 数据库设计

```prisma
model Plugin {
  id          String         @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  name        String         @db.VarChar(100)
  slug        String         @unique @db.VarChar(100)
  description String?        @db.Text
  version     String         @db.VarChar(20)
  author      String?        @db.VarChar(100)
  category    PluginCategory
  configSchema Json?         @map("config_schema")
  defaultConfig Json?        @map("default_config")
  mcpConfig   Json?          @map("mcp_config")
  isOfficial  Boolean        @default(false) @map("is_official")
  isEnabled   Boolean        @default(true) @map("is_enabled")
  downloadUrl String?        @map("download_url") @db.VarChar(500)
  createdAt   DateTime       @default(now()) @map("created_at")
  updatedAt   DateTime       @updatedAt @map("updated_at")

  installations BotPlugin[]

  @@index([category])
  @@index([isOfficial])
  @@map("plugin")
}

enum PluginCategory {
  BROWSER
  FILESYSTEM
  DATABASE
  API
  COMMUNICATION
  DEVELOPMENT
  CUSTOM
}

model BotPlugin {
  id        String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  botId     String   @map("bot_id") @db.Uuid
  pluginId  String   @map("plugin_id") @db.Uuid
  config    Json?
  isEnabled Boolean  @default(true) @map("is_enabled")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  bot    Bot    @relation(fields: [botId], references: [id], onDelete: Cascade)
  plugin Plugin @relation(fields: [pluginId], references: [id], onDelete: Cascade)

  @@unique([botId, pluginId])
  @@index([botId])
  @@index([pluginId])
  @@map("bot_plugin")
}
```

### 4.4 API 契约

```typescript
export const pluginContract = c.router({
  list: {
    method: 'GET',
    path: '/plugins',
    query: PluginListQuerySchema,
    responses: { 200: createApiResponse(PaginatedResponseSchema(PluginItemSchema)) },
  },
  install: {
    method: 'POST',
    path: '/bot/:hostname/plugins',
    pathParams: z.object({ hostname: z.string() }),
    body: InstallPluginSchema,
    responses: { 200: createApiResponse(BotPluginSchema) },
  },
  uninstall: {
    method: 'DELETE',
    path: '/bot/:hostname/plugins/:pluginId',
    pathParams: z.object({ hostname: z.string(), pluginId: z.string().uuid() }),
    responses: { 200: createApiResponse(z.object({ success: z.boolean() })) },
  },
  getBotPlugins: {
    method: 'GET',
    path: '/bot/:hostname/plugins',
    pathParams: z.object({ hostname: z.string() }),
    responses: { 200: createApiResponse(z.array(BotPluginSchema)) },
  },
});
```

### 4.5 关键文件清单

| 文件 | 操作 | 说明 |
|------|------|------|
| `apps/api/prisma/schema.prisma` | 修改 | 添加 Plugin、BotPlugin 模型 |
| `packages/contracts/src/schemas/plugin.schema.ts` | 新建 | 插件 Schema |
| `packages/contracts/src/api/plugin.contract.ts` | 新建 | 插件契约 |
| `apps/api/src/modules/plugin-api/` | 新建 | 插件 API 模块 |
| `apps/api/src/modules/bot-api/services/workspace.service.ts` | 修改 | 支持插件目录 |
| `apps/web/app/[locale]/(main)/plugins/page.tsx` | 新建 | 插件市场页面 |
| `apps/web/app/[locale]/(main)/bots/[hostname]/plugins/page.tsx` | 新建 | Bot 插件管理 |

---

## 5. 实施优先级与路线图

### 5.1 优先级矩阵

| 功能 | 优先级 | 复杂度 | 依赖 |
|------|--------|--------|------|
| Token 提取 | P0 | 中 | 无 |
| Docker 事件监听 | P0 | 中 | 无 |
| SSE 实时推送 | P0 | 低 | Docker 事件监听 |
| 用量统计 API | P0 | 中 | Token 提取 |
| 用量前端页面 | P1 | 中 | 用量统计 API |
| 健康检查 | P1 | 低 | 无 |
| 插件系统 | P2 | 高 | 无 |

### 5.2 实施路线图

```
Phase 1 (Week 1-2): 基础监控
├── Token 提取服务
├── Docker 事件监听器
├── SSE 实时推送
└── 数据库迁移

Phase 2 (Week 3-4): 用量分析
├── 用量统计 API
├── 趋势数据 API
├── 分组统计 API
└── 前端用量页面

Phase 3 (Week 5-6): 健康监控
├── 健康检查服务
├── 状态超时处理
├── 告警通知
└── 前端状态展示优化

Phase 4 (Week 7-10): 插件系统
├── 插件数据模型
├── 插件 API
├── 插件市场页面
├── Bot 插件管理
└── OpenClaw 集成
```

### 5.3 风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 流式响应 Token 提取困难 | 部分请求无法统计 | 使用估算或请求后端 API |
| Docker 事件监听断开 | 状态不同步 | 自动重连 + 定期对账 |
| 插件安全风险 | 系统被攻击 | 沙箱隔离 + 权限控制 |

---

## 附录：参考资源

- [OpenClaw Extension Ecosystem](https://help.apiyi.com/en/openclaw-extensions-ecosystem-guide-en.html)
- [OpenClaw Custom Skill Creation](https://zenvanriel.nl/ai-engineer-blog/openclaw-custom-skill-creation-guide/)
- [OpenClaw Docker Deployment](https://zenvanriel.nl/ai-engineer-blog/openclaw-docker-deployment-guide/)
- [Docker Events API](https://docs.docker.com/engine/api/v1.43/#tag/System/operation/SystemEvents)
